@c -*-texinfo-*-

@c  Copyright (c) 1996 Blake McBride
@c  All rights reserved.
@c
@c  Redistribution and use in source and binary forms, with or without
@c  modification, are permitted provided that the following conditions are
@c  met:
@c
@c  1. Redistributions of source code must retain the above copyright
@c  notice, this list of conditions and the following disclaimer.
@c
@c  2. Redistributions in binary form must reproduce the above copyright
@c  notice, this list of conditions and the following disclaimer in the
@c  documentation and/or other materials provided with the distribution.
@c
@c  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
@c  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
@c  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
@c  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
@c  HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
@c  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
@c  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
@c  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
@c  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
@c  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
@c  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


@chapter Concepts

The Windows environment has its own lexicon and way of doing things.
This chapter is designed to explain that lexicon and give the programmer
a certain comfort level with respect to elements of Windows programming.

@section Windows
Windows are the rectangular region on your screen where a user interacts
with the application.  There are many things which may be done with a window.
Typically, a user may move, resize or change a window into an icon.  Actually,
dialogs and controls (discussed further down) are actually little windows
located inside bigger windows.  Therefore, it is also possible for a user to
interact in a very of ways with a specific window.

There are many attributes which may be associated with a window.  Each
window may have a system menu associated with it, a title bar, a
minimize/maximize buttons, various colors, sizes, positions, and border
types.  

There are three main window types: main, child and popup.



@subsection Main Window
There is normally exactly one main window associated with any given
application.  This is the first window which comes up when an application
starts up, the one which acts as the fulcrum for all the facilities of
the application, and the one which contains the main menu associated with
the application.  This is also the window which has the application icon
associated with it.  This is so when the application is iconized the
appropriate icon will displayed.

@subsection Child Window
In addition to the main window, there are child windows.  A child window
is a rectangular region or window which is directly associated with
some other (parent) window.  Child windows are always restricted to being
located inside its parent window.  It can't be moved outside its parent.
Also, when a parent window gets iconized (minimized into an icon), its
child windows follow suit.  When a parent window gets moved across the
screen, the child windows will follow such that their relative position
in their parent remains constant.  When a child window is created it
is positioned relative to its parent.  

@subsection Popup Window
In addition to child windows, the system also supports popup windows.  A
popup window is a rectangular region which acts, to a greater or lesser
extent, independently of any other window.  A popup window may exist
outside of any other window and be moved or resized independent of any
other window.  Popup windows may or may not have a parent.  If a parent
window is associated with a popup and the parent gets iconized, the
popup will follow suit.  If no parent is associated with a popup it can
be iconized independent of any other window.  Since popup windows are
independent of other windows, they are created with positions which are
relative to the entire screen.

@section Menus
Menus are the words or labels which typically appear at the top of the
main window associated with an application.  The user is able to select
various application functions by selecting the appropriate menu option.
Each menu option may also present the user with additional menu options
down to a number of levels.

@section Dialogs
Once a user selects a particular application function through the
application menu, an applications principal method of providing the user
with information, or obtaining information from, is through dialogs.  A
dialog is a rectangular region (or more precisely, a window) which
contains various display information and input fields (controls).

There are two fundamental dialog types: model and modeless.

@subsection Modal Dialogs
A modal dialog is one which must be completed or canceled prior to
accessing any other part of a given application.  If the user is
presented with a modal dialog and attempts to activate another window
within the same application, the system will just beep.  This dialog
type, however, does not restrict the user from accessing other
applications.

Modal dialogs are used most often because the complexity of an application
would grow tremendously if the user were allowed to be in multiple parts
of the same application at the same time.

@subsection Modeless Dialogs
Modeless dialogs allow the user to switch from one part of a particular
application to another without completing or canceling the modeless dialog.
The user may switch to another part of an application, obtain additional
information, and then return to any portion of the modeless dialog to
complete it.  The user may even iconize the dialog for another time.

Modeless dialogs are more complex and less frequently used than modal
dialogs.

@section Controls
Controls are the primary method of obtaining information from the user.
They are the input fields, push buttons, selection boxes, scroll bars,
etc.  Although Windows supports a group of standard controls, there is
an endless number of possible types of controls.  WDS supports all
standard Windows controls in addition to providing several additional
ones and enhancements to the standard ones.

@subsection Text Control
Text controls are used to obtain textual information in the form
of character strings.  WDS provides a variety of enhancements to
the standard Windows text controls.


@subsection Numeric Control
Numeric controls are a WDS supplied control used to obtain numeric
data from the user.

@subsection Date Control
Date controls are a WDS supplied control used to obtain date information
from the user.

@subsection Push Button
Push buttons are Windows supplied, WDS enhanced, controls which allow
the user to evoke an immediate action function.  For example, the
common ``OK'' and ``CANCEL'' buttons are push buttons.  The user
clicks on the button and some action gets evoked.

@subsection Check Box
Check boxes are Windows supplied, WDS enhanced, controls which allow
the user to select among non-exclusive yes/no, on/off type options.

@subsection Radio Button
Radio buttons are Windows supplied, WDS enhanced, controls which allow
the user to select one option among a group of mutually exclusive options.

@subsection List Box
List boxes allow the user to select items from a list of options.  The
list may be fully displayed, scrollable or drop down in nature.

@subsection Combo Box
Combo boxes are a combination of the text control and the list box.
With combo boxes, a user my select among a list of options or type
in a new item.

@subsection Scroll Bar
Scroll bars allow the user to visually select a position within some
application specific range via the mouse.

@section Help System
Windows provides a powerful help system which enables the user to obtain
interactive application specific help information via a ``Help'' menu
option or within a specific context via the ``F1'' key.  WDS supports
and makes it easy to use all capabilities of the Windows help system.

@section Cursors
Cursors are the visual elements which indicate where a users input focus
is or where he wishes it to be.  Cursors can also be used to indicate
something about the input mode or system status (for example the hour
glass is used to indicate that the system is busy).  Common cursors are
the underscore, the arrow, the ibeam, and the hour glass.

@subsection System Cursors
System cursors are common cursors which are predefined by the system.
These include most of the cursors most applications would need (such as
the underscore, the arrow, the ibeam, and the hour glass) and are easy to
select and use.

@subsection External Cursors
External cursors are cursors which are application specific and
created by the programmer.  These cursors may look like virtually
anything.

@section Icons
Icons are those little picture boxes which are left when an application
is minimized.  It is normally something the user can identify the
application with in order to reactive it.

@subsection System Icons
System icons are those generic icons which are predefined by Windows.
These system defined icons are easy to select and use, but are of a bit
less value since they have little to do with any specific application.

@subsection External Icons
External icons are application specific and programmer created icons.
They must be designed by the programmer prior to use, but are very
flexible, easy to design, and help the user identify the application.

@section Fonts
Fonts are the types (such as Helvetica or times) and size (i.e. 10pt)
of the characters which appear within an application.  There are
literally thousands to choose from.  Fortunately, however, the system
defaults are often sufficient.

@subsection System Fonts
The system fonts are those fonts which the user has configured his
system to use on a global basis.  Use of these fonts makes an
application have a familiar look and feel when compared to the rest of
the apps on the users machine.

@subsection External Fonts
External fonts are programmer selectable fonts and may be any of the
many fonts available to the Windows system.

@section Brushes
Brushes specify the color and pattern which appears in a window background,
in text and graphics.

@subsection System Brushes
System brushes are those colors which were selected by the user as
global to their Windows environment.  The programmer may select, for
example, the color the user chose for background windows.  The
new brush will then have colors the same colors that the user is used
to seeing in other applications on their system.  System brushes are
used most often.

@subsection Stock Brushes
Stock brushes allow the programmer to select from a number of common,
Windows defined, brushes.

@subsection Solid Brushes
Solid brushes are arbitrary color solid brushes which may be selected
by the programmer.

@subsection Hatch Brushes
Hatch brushes enable the programmer to select from any color and any of
a number of Windows defined hatch patterns.

@section Pens
Pens are used, principally in graphics, for drawing lines or providing
the outline of a figure.  The attributes associated with a pen includes
color of the line, width of the line, and its style.  Common styles
include solid, dashed, doted, etc.

@subsection Stock Pens
Stock pens allows a programmer to select among a few, common, Windows
defined pens.

@subsection Custom Pens
Using a custom pen allows the programmer to specify the exact attributes
associated with a particular pen.

@section Common Dialogs
Windows provides a few common dialogs in order to obtain frequently
needed information in a uniform format.  Use of these dialogs when
appropriate eases the programming normally associated with dialog
creation and provides the user with a familiar interface.

@subsection Color Dialog
The color dialog provides a convenient method of requesting detailed
color selection information from the user.

@subsection Font Dialog
The font dialog provides a convenient method of requesting detailed
font selection information from the user.

@subsection File Dialog
The file dialog provides a convenient method of allowing the user to
view and select files.

@subsection Print Dialog
The print dialog provides a convenient method of selecting and configuring
the printer.

@section Printing
WDS provides many convenient and easy to use methods of selecting and
configuring printers as well creating reports with a variety of fonts
and graphics.


@section Resources
Windows programs may use application specific icons, dialogs, menus and
cursors.  These items are referred to as resources.  Each resource has a
name and may be accessed by the application program.  Resources are
created with a graphically oriented tool called a @emph{resource editor}.

Once the needed resources are created, the resource editor saves them to
a file called the resource file.  The contents of the resource file are
then compiled into a binary form using a @emph{resource compiler}.
Finally, the compiled resource file is combined with the executable file
at link time.

Resource editors and compilers are included and documented along with
your C compiler package.  The resource editor associated with
Microsoft's Visual C++ is called @emph{App Studio}.  WATCOM calls theirs
the @emph{WATCOM Resource Editor} and Borland calls theirs
@emph{Resource Workshop}.



@section Dynamic Link Libraries (DLL)
Normally, when a program is linked, all of the library code which is
accessed gets copied to the executable being created.  Therefore, when
the program is run, all the necessary routines are readily available in
the executable file.  This is called static linking.

When using DLLs, at link time the linker copies very small stub
functions instead of the real routines into the executable file.  These
stub functions, when called by the application code, automatically
access the real routines at run time which exist in external DLL files.
This is called dynamic linking because it happens dynamically at run time.

The actual code which uses statically or dynamically linked routines is
exactly the same.  In other words, the process of writing code doesn't
change.  The only difference is the link commands used and the fact that
dynamic linking requires that the DLLs be available at run time.

There are three advantages to using DLLs.  The first is that if you have
several apps which use the same library routines, you can save disk
space by only requiring one copy of the routines on disk (in the DLL
instead of a copy in each executable file).

The second is that since Windows knows that both apps are sharing the
exact same code (because they use the same DLL), if the user activates
both apps, Windows only needs to load one copy of the routines in memory
and share the same code for both apps.  This saves memory space.

The third advantage of using DLLs is that if you have several apps which
use the same routine, and a bug is discovered in that routine, only the
DLL needs to be updated.  None of the apps will have to be re-linked.
The next time any of the apps are run, it will load the new, and repaired,
routine.

There are also a couple of drawbacks associated with the use of DLLs.
First, instead of just using an executable file (as is the case with
statically linked executables) you must make sure to install the appropriate
DLLs.  This complicates the installation process.

The second, and more troublesome, problem associated with DLLs has to do
with versions.  Lets say you have some app which uses some common DLL.
Everything is compiled and linked and runs well.  Several months go by
and you start working on a new project.  While developing the new app
you decide to use some routine in your common DLL which used by the
first app.  While using the routine located in the DLL you discover a
bug or anomaly in the routine, you therefore decide to correct it.
Now the second app works fine.  A month later you try to use the first
app again and it now has all sorts of bugs!  How could this happen?
It always worked before and you haven't changed it.

What happened is that the first app depended on a particular anomaly
associated with the original version of the routine located in the DLL.
When the anomaly was corrected, it mysteriously broke the first app.
This scenario is more common and troublesome than it may appear!



@section Win16, Win32, Win32s
Microsoft has two independent but similar models in which an application
may run.  Each model has an associated application program interface
(API) or library which it links with and uses in order to interface with
the OS.  The two APIs are called Win16 and Win32.

Win16 is a 16 bit interface designed to run on Windows 3.1.  All common
Windows 3.1 apps are created using this API.  This API has the advantage
of being portable to the most environments.  Although it will only
support 16 bit applications, these apps will run on Windows 3.1, Windows
'95 and Windows NT.

Win32 on the other hand is a full featured 32 bit API.  The syntax of
this API is very similar but not exactly the same as Win16.  The main
differences have to do with the fact that in a 32 bit environment
@code{int}'s are 32 bits instead of 16.  Win32 and Win16 are similar
enough, however, that with a little planning, it is not difficult to
create apps which are compile time portable between Win16 and Win32.
Windows NT is the primary host for Win32 applications, however,
these 32 bit applications may run on 16 bit Windows 3.1 as follows.

In order to bridge the gulf between Win16 and Win32 and allow 32 bit
applications to run under Windows 3.1, Microsoft created Win32s.  Win32s
is a large subset of Win32 which supports the same syntax as Win32,
supports 32 bit apps, and will run on Windows 3.1 and NT.  In order to
run on 16 bit Windows 3.1 it is necessary to install some 32 bit
extensions to Windows 3.1.  These extensions come with the C compiler
packages and are freely redistributable.  Win32s apps will run in true
32 bit mode under Windows 3.1 or Windows NT using the same executable.

It is important to note that there is no difference between creating a
Win32 or Win32s application.  Both use the same compiler, compiler
flags, linker, linker flags and libraries.  The exact same executable
is built.  There is no way to specifically tell the system which type of
application you wish.  The @emph{only} difference between the two is
which specific APIs your application calls.

If your application only calls those APIs which are common to Win32
and Win32s then your application will run as a Win32 application under
NT and a Win32s under Windows 3.1.  However, if your application makes
any API calls which are specific to Win32 then those calls will not
work under Windows 3.1.

WDS supports Win16 and Win32.  In addition, WDS only uses those APIs
which are available under Win32s, therefore, WDS applications will
run fine under Win32s.

@section Message Passing Architecture
Most character based applications are pretty simple in the sense that
they (in one form or another) basically get a key, perform some processing,
get the next key, perform some more processing, etc.  In a graphical
environment (such as Windows) this model doesn't work.  At any point
(like in the middle of entering data in a field) the user may decide
to move or resize a window and the application has to be able to
handle a myriad of possible input requests (messages) at any point.
In order to accommodate this fact, Windows programming uses a different
programming model called @emph{Message Driven Architecture} (MDA).

MDA is tremendously more complex and requires much more code to handle
than the old get-key model.  The main benefit of the Dynace Windows
Development System is that WDS encapsulates and hides most of the
aspects of MDA.  With WDS you can code in a simple, familiar way and
produce full featured Windows applications.

